#!/usr/bin/env ruby

EMACS = '/Applications/Aquamacs.app/Contents/MacOS/Aquamacs'
ROOT = File.expand_path('..', File.dirname(__FILE__))
PATHS = ["#{ROOT}/lib", "#{ROOT}/vendor"]

require 'optparse'
require 'fileutils'

class App
  def initialize(args)
    @opts = {}
    parser = OptionParser.new do |parser|
      parser.banner = <<-EOS.gsub(/^.*\|/, '')
        |USAGE: #$0 [-c]
        |
        |Compile sources files and generate autoload files.
        |
        |Do this recursively for all .el files in any given
        |directories.
      EOS

      parser.on('-c', '--clean', 'Remove all generated files first.') do
        @opts[:clean] = true
      end
    end
    parser.parse!(ARGV)
    @paths = (args.empty? ? PATHS : args).map { |path| File.expand_path(path) }
  end

  def run
    clean(@paths) if @opts[:clean]
    @sources = find_sources
    compile
    generate_autoloads
  end

  private

  def clean(args)
    args.each do |path|
      FileUtils.rm_rf("#{ROOT}/var/autoloads/#{path}")
      if File.directory?(path)
        system 'find', path, '-name', '*.elc', '-exec', 'rm', '-f', '{}', ';'
      else
        FileUtils.rm_f "#{path}c"
      end
    end
  end

  def rc_load_path
    @paths.map do |path|
      `find \"#{path}\" -type d`.split(/\n/)
    end.flatten
  end

  def rc_load_path_as_list
    quoted_dirs = rc_load_path.map { |dir| "\"#{dir}\"" }
    "(list #{quoted_dirs.join(' ')})"
  end

  def find_sources
    rc_load_path.map do |path|
      Dir["#{path}/*.el"]
    end.flatten
  end

  def compile
    files = @sources.select { |src| stale?("#{src}c", src) }
    # aquamacs-mode-defaults adds edit-modes directories to the load path
    lisp = <<-EOS
      (progn
        (require 'aquamacs)
        (require 'aquamacs-aux)
        (require 'aquamacs-mode-defaults)
    EOS
    system EMACS, '-batch', '-q', '-eval', lisp.gsub(/\s+/m, ' '), '-f', 'batch-byte-compile', *files
  end

  def generate_autoloads
    snippets = @sources.map do |src|
      dst = "#{ROOT}/var/autoloads/#{src}"
      src = "#{ROOT}/#{src}"
      next if !stale?(dst, src)

      <<-EOS
        (with-current-buffer (autoload-find-file "#{src}")
          (make-directory "#{File.dirname dst}" t)
          (setq generated-autoload-file "#{dst}")
          (update-file-autoloads "#{src}" t))
      EOS
    end.join
    return if snippets.empty?
    lisp = <<-EOS
      (progn
        (require 'autoload)
        (setq backup-inhibited t)
        #{snippets})
    EOS
    system EMACS, '-batch', '-q', '-eval', lisp.gsub(/\s+/m, ' ').strip
  end

  def stale?(dst, src)
    !File.exist?(dst) || File.mtime(dst) < File.mtime(src)
  end
end

App.new(ARGV).run
